## 01背包问题(每个物品最多只用一次)
[动态规划专题——背包问题_动态规划 背包问题_Iareges的博客-CSDN博客](https://blog.csdn.net/raelum/article/details/128996521)
设dp\[ i ]的含义是: 在背包承重为 j 的前提下，从前 i 个物品中选能够得到的最大价值。不难发现dp[ N ]\[ M ]就是本题的答案。
如何计算dp\[i]\[j]呢？我们可以将它划分为以下两部分：
- 选第i个物品: 由于第i个物品一定会被选择，那么相当于从前i-1个物品中选且总重量不超过j-w\[i],对应dp\[i-1]\[j - w\[ i ]] + v\[i]。
- 不选第i个物品: 意味着从前i-1个物品中选且总重量不超过j,对应dp\[i-1]\[j]。

结合以上两点可得递推公式:
dp\[i]\[j] = max(dp\[i - 1]\[j], dp\[ i- 1]\[j - w\[ i ]] + v\[i]) 

![image.png](https://gitee.com/XXXTENTWXD/pic/raw/master/images/20230825000115.png)

```c++
二维版
#include<iostream>

using namespace std;

const int N = 1010;
int n,m;
int v[N],w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            if(j < v[i]) f[i][j] = f[i-1][j];
            else f[i][j] = max(f[i-1][j-v[i]] + w[i], f[i-1][j]);
        }
    }
    
    cout << f[n][m];
    
    return 0;
}

```

## 完全背包（每个物品可以用多次）
有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

### 1. 确定dp数组以及下标的含义
dpij 表示从下标为[0-i]的物品，每个物品可以取无限次，放进容量为j的背包，价值总和最大是多少。

### 2. 确定递推公式

- **不放物品i**：背包容量为j，里面不放物品i的最大价值是dp(i -1)(j)。
    
- **放物品i**：背包空出物品i的容量后，背包容量为j - weight[i]，dp(i)(j - weight(i)) 为背包容量为j - weight[i]且不放物品i的最大价值，那么dp(i)(j - weight(i)) + value[i] （物品i的价值），就是背包放物品i得到的最大价值
    

递推公式： `dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);`