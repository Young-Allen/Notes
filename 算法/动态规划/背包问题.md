## 01背包问题(每个物品最多只用一次)
[动态规划专题——背包问题_动态规划 背包问题_Iareges的博客-CSDN博客](https://blog.csdn.net/raelum/article/details/128996521)
设dp\[ i ]的含义是: 在背包承重为 j 的前提下，从前 i 个物品中选能够得到的最大价值。不难发现dp[ N ]\[ M ]就是本题的答案。
如何计算dp\[i]\[j]呢？我们可以将它划分为以下两部分：
- 选第i个物品: 由于第i个物品一定会被选择，那么相当于从前i-1个物品中选且总重量不超过j-w\[i],对应dp\[i-1]\[j - w\[ i ]] + v\[i]。
- 不选第i个物品: 意味着从前i-1个物品中选且总重量不超过j,对应dp\[i-1]\[j]。

结合以上两点可得递推公式:
dp\[i]\[j] = max(dp\[i - 1]\[j], dp\[ i- 1]\[j - w\[ i ]] + v\[i]) 

![image.png](https://gitee.com/XXXTENTWXD/pic/raw/master/images/20230825000115.png)

```c++
二维版
#include<iostream>

using namespace std;

const int N = 1010;
int n,m;
int v[N],w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            if(j < v[i]) f[i][j] = f[i-1][j];
            else f[i][j] = max(f[i-1][j-v[i]] + w[i], f[i-1][j]);
        }
    }
    
    cout << f[n][m];
    
    return 0;
}

```

## 完全背包（每个物品可以用多次）
有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

### 1. 确定dp数组以及下标的含义
dpij 表示从下标为[0-i]的物品，每个物品可以取无限次，放进容量为j的背包，价值总和最大是多少。

### 2. 确定递推公式

- **不放物品i**：背包容量为j，里面不放物品i的最大价值是dp(i -1)(j)。
    
- **放物品i**：背包空出物品i的容量后，背包容量为j - weight[i]，dp(i)(j - weight(i)) 为背包容量为j - weight[i]且不放物品i的最大价值，那么dp(i)(j - weight(i)) + value[i] （物品i的价值），就是背包放物品i得到的最大价值
    

递推公式： `dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);`

零钱兑换
https://leetcode.cn/problems/coin-change-ii/

### 一维DP的排列组合问题
排列是考虑顺序的，组合是不考虑顺序的。
所以，先遍历coins，再遍历背包会出现，固定的顺序，比如说如果为4时，则（1 + 1 + 2），因为需要先计算前面顺序的coin在计算后面的coin，这样就是固定了顺序的，这样就叫做排列了；
而先遍历背包再遍历coin，则是在固定金额的时候，去考虑有多少种硬币可以填满。如果金额为2，则（1 + 1）（2）。
**所以总结下来，
如果求组合数就是外层for循环遍历物品，内层for遍历背包。
如果求排列数就是外层for遍历背包，内层for循环遍历物品**。
「
先物品后背包的情况下，根据递推公式，dp【j】一定是来自于外层上一次的结果，而外层上一次的结果一定是来源于上一个物品的dp数组，所以不会出现物品2在物品1之前的情况，也就是只会出现【物品1，物品1，物品2】这种情况，而物品2不会出现在物品1之前，恰好对应组合问题；

而外层遍历背包内层遍历物品就不一样了，每一层的dp【j】都是在固定j的情况下，把物品从头开始遍历，所以dp【j】来自于上一层的结果，而上一层的结果又遍历了所有物品，所以这种遍历方式会出现【物品1，物品2，物品1】这种情况，恰好对应了排列问题
」